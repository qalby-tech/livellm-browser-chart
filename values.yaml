# Default values for livellm-browser
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: kamasalyamov/livellm-browser
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Environment variables for the container
env:
  # VNC password
  VNC_PW: "headless"
  # VNC resolution
  VNC_RESOLUTION: "1920x1080"
  # Display number
  DISPLAY: ":1"

# Additional environment variables from ConfigMap or Secret
envFrom: []
# - configMapRef:
#     name: my-configmap
# - secretRef:
#     name: my-secret

# Service account configuration
serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

podAnnotations: {}
podLabels: {}

# Pod-level security context
podSecurityContext:
  seccompProfile:
    type: Unconfined

# Container-level security context
# Chrome/Chromium needs relaxed security to run in Kubernetes
securityContext:
  allowPrivilegeEscalation: true
  privileged: false
  capabilities:
    add:
      - SYS_ADMIN  # Required for some browser sandboxing features
# Service configuration - exposes VNC, noVNC, and FastAPI ports
service:
  type: ClusterIP
  # VNC port
  vnc:
    port: 5901
    targetPort: 5901
  # noVNC web interface port
  novnc:
    port: 6901
    targetPort: 6901
  # FastAPI Controller port
  api:
    port: 8000
    targetPort: 8000

# Ingress configuration for web access
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: livellm-browser.local
      paths:
        - path: /parser
          pathType: Prefix
          # Which service port to use: novnc or api
          servicePort: api
  tls: []
  #  - secretName: livellm-browser-tls
  #    hosts:
  #      - livellm-browser.local

# Resource limits and requests matching compose config
resources:
  limits:
    cpu: "2"
    memory: "4Gi"
  requests:
    cpu: "2"
    memory: "4Gi"

# Shared memory size for browsers (important for Chrome/Firefox)
# This creates an emptyDir volume with medium: Memory
shmSize: "4Gi"

# Persistent volume for browser profiles
# This is the only persistent storage needed - stores browser profile data
# Note: For autoscaling with multiple replicas, use ReadWriteMany (requires NFS/CephFS)
#       or disable persistence if profiles don't need to be shared
persistence:
  profiles:
    enabled: true
    storageClass: ""
    # Use ReadWriteMany for autoscaling, ReadWriteOnce for single replica
    accessMode: ReadWriteMany
    size: 2Gi
    # Use existing PVC instead of creating a new one
    existingClaim: ""
    # Mount path inside the container (matches PROFILES_DIR in main.py)
    mountPath: /home/headless/Desktop/app/profiles

# Liveness probe configuration
livenessProbe:
  enabled: true
  httpGet:
    path: /ping
    port: api
  initialDelaySeconds: 180
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

# Readiness probe configuration
readinessProbe:
  enabled: true
  httpGet:
    path: /ping
    port: api
  initialDelaySeconds: 180
  periodSeconds: 30
  timeoutSeconds: 3
  failureThreshold: 3

# Autoscaling configuration
# Note: Requires metrics-server installed in cluster
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Additional volumes
volumes: []
# - name: custom-volume
#   configMap:
#     name: my-config

# Additional volume mounts
volumeMounts: []
# - name: custom-volume
#   mountPath: /custom/path
#   readOnly: true

nodeSelector:
  kubernetes.io/os: linux
  kubernetes.io/arch: amd64 # arm64 is not supported

tolerations: []

affinity: {}

# Deployment strategy
# Using RollingUpdate for autoscaling support
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0
  # Use Recreate for single-replica stateful workloads with RWO PVCs:
  # type: Recreate
