# Default values for livellm-browser
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: kamasalyamov/livellm-browser
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Environment variables for the container
env:
  # VNC password
  VNC_PW: "headless"
  # VNC resolution
  VNC_RESOLUTION: "1920x1080"
  # Display number
  DISPLAY: ":1"

# Additional environment variables from ConfigMap or Secret
envFrom: []
# - configMapRef:
#     name: my-configmap
# - secretRef:
#     name: my-secret

# Service account configuration
serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

podAnnotations: {}
podLabels: {}

# Pod-level security context
podSecurityContext:
  # fsGroup ensures volume permissions are set correctly for the headless user (UID 1000)
  # NOTE: Do NOT set runAsUser/runAsGroup here - the accetto base image needs to start
  # as root to run its user generation script, then switches to the headless user
  fsGroup: 1000

# Container-level security context
# Chrome/Chromium needs relaxed security to run in Kubernetes
securityContext:
  # Required for Chrome to run properly in Kubernetes
  # Chrome uses clone() and other syscalls that seccomp blocks by default
  seccompProfile:
    type: Unconfined
  # SYS_PTRACE is required for Chrome's remote debugging pipe to work
  # Without it, Chrome crashes immediately with SIGTRAP signal
  capabilities:
    add:
      - SYS_PTRACE

# Service configuration - exposes VNC, noVNC, and FastAPI ports
service:
  type: ClusterIP
  # VNC port
  vnc:
    port: 5901
    targetPort: 5901
  # noVNC web interface port
  novnc:
    port: 6901
    targetPort: 6901
  # FastAPI Controller port
  api:
    port: 8000
    targetPort: 8000

# Ingress configuration for web access
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: livellm-browser.local
      paths:
        - path: /parser
          pathType: Prefix
          # Which service port to use: novnc or api
          servicePort: api
  tls: []
  #  - secretName: livellm-browser-tls
  #    hosts:
  #      - livellm-browser.local

# Resource limits and requests matching compose config
resources:
  limits:
    cpu: "1"
    memory: "4Gi"
  requests:
    cpu: "500m"
    memory: "2Gi"

# Shared memory size for browsers (important for Chrome/Firefox)
# This creates an emptyDir volume with medium: Memory
shmSize: "4Gi"

# Persistent volume for browser profiles
# This is the only persistent storage needed - stores browser profile data
persistence:
  profiles:
    enabled: true
    storageClass: ""
    accessMode: ReadWriteOnce
    size: 2Gi
    # Use existing PVC instead of creating a new one
    existingClaim: ""
    # Mount path inside the container (matches PROFILES_DIR in main.py)
    mountPath: /home/headless/Desktop/app/profiles

# Liveness probe configuration
livenessProbe:
  enabled: true
  httpGet:
    path: /ping
    port: api
  initialDelaySeconds: 180
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

# Readiness probe configuration
readinessProbe:
  enabled: true
  httpGet:
    path: /ping
    port: api
  initialDelaySeconds: 180
  periodSeconds: 30
  timeoutSeconds: 3
  failureThreshold: 3

# Autoscaling configuration (disabled by default for stateful workloads)
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Additional volumes
volumes: []
# - name: custom-volume
#   configMap:
#     name: my-config

# Additional volume mounts
volumeMounts: []
# - name: custom-volume
#   mountPath: /custom/path
#   readOnly: true

nodeSelector:
  kubernetes.io/os: linux
  kubernetes.io/arch: amd64 # arm64 is not supported

tolerations: []

affinity: {}

# Deployment strategy
strategy:
  type: Recreate
  # Use Recreate for stateful workloads with PVCs
  # For rolling updates, use:
  # type: RollingUpdate
  # rollingUpdate:
  #   maxSurge: 1
  #   maxUnavailable: 0
